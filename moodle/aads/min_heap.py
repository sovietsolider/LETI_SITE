def heapify(heap):
    N = len(heap)
    swaps = [] # пары индексов, которые нужно менять местами

    for k in range(int(N/2), -1, -1): # рассматриваем все узлы, кроме последнего уровня
        if k*2 + 1 >= N: # если 1ый дочерний узел выходит за пределы кучи, то узел является листом и рассматривать его нет смысла
            continue

        elem_k = heap[k] # значение рассматриваемого элемента
        i = j = k
        while i*2 + 1 < N: # пока i - не лист (идём сверху вниз)
            j = i*2 + 1 # j - индекс минимального дочернего узла
            if j + 1 < N and heap[j+1] < heap[j]: # если правый дочерний узел меньше левого (и существует), то его индекс и есть минимальный
                j += 1

            if heap[j] >= elem_k: # если минимальный дочерний узел больше текущего, то баланс кучи не нарушен и провеять дальше нет смысла
                break

            swaps.append((i, j))
            heap[i] = heap[j] # иначе обмениваем дочерний узел с родителем

            i = j

        heap[i] = elem_k # вставляем рассматриваемый элемент в конец цепочки обменов

    return swaps


n = int(input())
numbers = list(map(int, input().split()))

sw = heapify(numbers)
print(len(sw))
for i in range(0, len(sw)):
    print(sw[i][0], sw[i][1])
